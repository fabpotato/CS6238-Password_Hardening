package edu.gatech.scs.pwd.hardening;

import java.io.File;
import java.io.FileOutputStream;

import edu.gatech.scs.pwd.hardening.encryptAndDecrypt;

import java.math.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class initialize {


	/* Random Prime Number */
	BigInteger q;

	/* Coefficients */
	BigInteger[] c = new BigInteger[15];
	public static int setSize = 1024;

	
	//a is the alpha value for account a's ith feature
	BigInteger[] a=new BigInteger[16];

	//b is the beta value for account a's ith feature
	BigInteger[] b=new BigInteger[16];

	
	
	/* Constructor. */
	public initialize(){
		//create a BigInteger object
		BigInteger l;
		
		//Length of prime=160bits
		int bitlength=160;
		
		//Create a random object
		Random rnd= new Random();
		
		//assign probablePrime result to q using bit length and rnd.	
		q=BigInteger.probablePrime(bitlength, rnd);
		String str= "ProbablePrime of bitlength"+bitlength+" is " +q;
		System.out.println(str);
	}

	
	/* To choose a random polynomial f(x)=ckxk+⋯+c1x+c0 of degree k in the polynomial ring Zq[x] simply means choosing k+1 random coefficients c0,c1,⋯,ck uniformly from the finite field Zq. However, the additional constraint that f(0)=c0 should take a particular fixed value means that, in fact, only the k coefficients c1,…,ck can be chosen randomly, while the constant coefficient c0 is fixed.
	http://crypto.stackexchange.com/questions/6455/how-to-generate-a-random-polynomial-of-degree-m	*/		
			
	public void Polynomials(BigInteger q){
		// We need to generate 15 Random co-efficients and the c0 should be Hpwd.
		Random rand= new Random();
		for( int i=0;i <15;i++)
		{
			//Changing the value of c[0] to the Hpwd. Assuming Hpwd=12345
			if(i==0){
				
				c[0]= BigInteger.valueOf(1234567890);
				System.out.println(c[0]);
			}
				
			else	{
			c[i]=BigInteger.valueOf(rand.nextInt(1000)+1);  //Changed this from q to 100: Do Check again(Consult TA)
			System.out.println("Coefficient of x^"+i+" is "+c[i]);
			}
		}
		
	}


	/* Function to compute the value of alpha and beta */
	public void Instruction_Table()
	{
		//z[i] stands for the ith value of y for an account 'a'--> Similar to y(a,i,1) 
		BigInteger[] z=new BigInteger[15];
	
		//y[i] stands for the ith value of y for an account 'a'--> Similar to y(a,i,0) 
		BigInteger[] y=new BigInteger[15];
	

		/* Using Formulas for alpha and beta
			a[i]=y[i] + G(r,pwd)(2i)mod q
			b[i]=z[i] + G(r,pwd)(2i)mod q */
		
		for(int i=1;i<=15;i++)
		{
			a[i]= Polynomial_Calculation(2*i).multiply(generateHMac("password", Integer.toString(2*i), "HmacSHA256").mod(q));
			System.out.println("Alpha value is "+a[i]);
			b[i]= Polynomial_Calculation((2*i)+1).multiply(generateHMac("password", Integer.toString((2*i)+1), "HmacSHA256").mod(q));
			System.out.println("Beta value is "+b[i]);
		}

	}

	
	
	public long bytesToLong(byte[] bytes) 
	{
	    
        long r = 0;
        for (int i = 0; i < bytes.length; i++) {
            r = r << 8;
            r += bytes[i];
        }
	//System.out.println(r);
        return r;
    }

	
	
	/* Calculating value of Polynomial required for alpha and beta. */
	
	public BigInteger Polynomial_Calculation(int x)
	{
		BigInteger f=BigInteger.valueOf(0);
		for (int i=0;i<15;i++)
		{
			BigInteger mul = new BigDecimal(Math.pow(x,i)).toBigInteger();
			f=f.add(c[i].multiply(mul));
		}
		System.out.println("X and Y generated is "+x+"and "+f);
		return f;
	}
	
	
	/* Function to Compute Keyed Hash */
	public BigInteger generateHMac(String secretKey, String data, String algorithm /* e.g. "HmacSHA256" */)
	{

	    	SecretKeySpec signingKey = new SecretKeySpec(secretKey.getBytes(), algorithm);

		try {
			Mac mac = Mac.getInstance(algorithm);
			mac.init(signingKey);
			//System.out.println(mac.doFinal(data.getBytes()));
			
			return new BigInteger(mac.doFinal(data.getBytes()));
		    }
		    catch(InvalidKeyException e) {
			throw new IllegalArgumentException("invalid secret key provided (key not printed for security reasons!)");
		    }
		    catch(NoSuchAlgorithmException e) {
			throw new IllegalStateException("the system doesn't support algorithm " + algorithm, e);
		    }
	}

	
	/* History File Creation and Updation. */
	public void History_File()
	{
		try
		{
			
			File f = new File("Dec_History_File.txt");
			FileOutputStream History_file= new FileOutputStream("Dec_History_File.txt");
			//long size = f.getTotalSpace();
			//System.out.println("Size of file: " + size);
			//History_file.write("This is the History File".getBytes());
			long size = f.length();
			while(size<setSize-("This is the History File".getBytes().length))
			{
				History_file.write("00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n".getBytes());
				size=f.length();
			}
			History_file.write("This is the History File".getBytes());
			History_file.close();
		}
		catch(Exception e){
			System.err.println(e);}
		
	}
	
	
}
